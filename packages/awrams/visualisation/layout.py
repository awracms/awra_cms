import matplotlib
import matplotlib.pyplot as plt
from mpl_toolkits.axes_grid1 import make_axes_locatable
import numpy as np
import pylab

import awrams.utils.datetools as dt
from awrams.utils.extents import *
from awrams.utils.helpers import shuffle
from awrams.utils.metatypes import *
from awrams.utils.ts.processing import *

o = ObjectDict

MIN_FIG_WIDTH = 800.0
MIN_FIG_HEIGHT = 600.0

NAN_FILTER_MAP = matplotlib.colors.ListedColormap([[0.5,0.5,0.5],[1,0,0]])
NAN_FILTER_MAP.set_bad((0.1,0.4,0.8))

def _get_ax(kwargs):
    ax = _get_kwd('ax',kwargs)
    if 'ax' is None:
        ax = plt.gca()
    return ax

def _get_kwd(k,kwargs):
    if k in kwargs:
        kwd = kwargs[k]
        del kwargs[k]
        return kwd
    else:
        return None

def get_graph_extent(extent):
    return shuffle(extent.bounding_rect(),[2,3,1,0])

def plot_single_grid(data,extent,show_bar=True,**kwargs):
    '''
    Standard plot method utilising coords generated by extent
    '''
    units = _get_kwd('units',kwargs)
    cmap = _get_kwd('cmap',kwargs)
    norm = _get_kwd('norm',kwargs)
    clim = _get_kwd('clim',kwargs)
    interpolation = _get_kwd('interpolation',kwargs) or 'none'

    ax = _get_ax(kwargs)

    im = ax.imshow(data,extent=get_graph_extent(extent),interpolation=interpolation,cmap=cmap,norm=norm,clim=clim)

    if show_bar:
        divider = make_axes_locatable(ax)
        cax = divider.append_axes("right", "5%", pad="3%")
        cb = plt.colorbar(im, cax=cax)
        cb.set_label(units)

    for k,v in kwargs.items():
        try:
            ax.set(**{k:v})
        except:
            pass


def plot_single_gridMinMax(data,extent,ax=None,labels=None,show_bar=True):
    '''
    Standard plot method utilising coords generated by extent
    '''
    if labels is None:
        labels = {}
    title = get_label(labels,'title')
    ylabel = get_label(labels,'ylabel')
    units = get_label(labels,'units')
    cmap = get_label(labels,'cmap')
    minval = get_label(labels,'minval')
    maxval = get_label(labels,'maxval')

    if ax == None:
        ax = plt.gca()

    formatter = matplotlib.ticker.ScalarFormatter(useOffset=False)
    ax.yaxis.set_major_formatter(formatter)
    ax.xaxis.set_major_formatter(formatter)

    ax.set_title(title)
    im = ax.imshow(data,extent=get_graph_extent(extent),interpolation="none",cmap=cmap)

    plt.ylabel(ylabel)
    if 'clim' in labels:
        im.set_clim(labels['clim'][0], labels['clim'][1])
    if show_bar:
        im.set_clim(minval,maxval)
        fig = ax.figure
        cb = fig.colorbar(im)
        cb.set_label(units)

def highlight_map(bg_colour,hl_colour,mask_colour=(1,1,1)):
    '''
    Generate a 3 colour map; zero vals will show as bg_colour,
    one vals as hl_colour, masked vals mask_colour
    '''
    cmap = matplotlib.colors.ListedColormap([bg_colour,hl_colour])
    cmap.set_bad(mask_colour)
    return cmap

def gen_title(title_pattern,subs_map,sub_source):
    '''
    Placeholder
    '''
    subs = []
    for sub in subs_map:
        subs.append(sub_source[sub])
    return title_pattern % tuple(subs)

def set_figsize_inches(width,height):
    pylab.rcParams['figure.figsize'] = (width,height)

def set_figsize_pixels(w,h):
    fig = plt.gcf()
    dpi = float(fig.get_dpi())
    width = w / dpi
    height = h / dpi
    pylab.rcParams['figure.figsize'] = (width,height)

def fig_params(w,h,dpi=100.0):
    width = w/dpi
    height = h/dpi
    return dict(figsize=(width,height), dpi=dpi)

def get_label(labels,key):
    if key in labels:
        return labels[key]
    else:
        return ''

class View(object):
    def __init__(self):
        pass

    def draw(self,ax):
        raise BaseException

class SpatialView(View):
    def __init__(self,data_ob,**ctl_dict):
        self.data = data_ob
        self.ctl_dict = ctl_dict

    def draw(self,ax):
        self.ax = ax
        plot_single_grid(self.data._data,self.data.extent,ax=ax,**self.ctl_dict)

class NoBarView(View):
    def __init__(self,data,labels=None):
        if labels is None:
            labels = {}
        self.data = data
        self.labels = labels

    def draw(self,ax):
        plot_single_grid(self.data.data,self.data.extent,ax=ax,labels=self.labels,show_bar=False)

class TimeSeriesView(View):
    def __init__(self,data,**ctl_dict):
        self.data = data
        self.ctl_dict = ctl_dict

    def draw(self,ax):
        if ax == None:
            ax = plt.gca()
        self.ax = ax

        legend = _get_kwd('legend',self.ctl_dict)

        self.data._data.plot(label=legend)
        if legend != '':
            plt.legend()

        for k,v in self.ctl_dict.items():
            try:
                ax.set(**{k:v})
            except:
                pass


class GridView(View):
    def __init__(self,rows,cols,x_scale=1.0,y_scale=1.0):
        self.rows = rows
        self.cols = cols
        self.children = np.empty(shape=(rows,cols),dtype=View)

        self.axes = plt.GridSpec(rows,cols)
        self.x_scale = x_scale
        self.y_scale = y_scale

    def __getitem__(self,idx):
        return self.children[idx]

    def __setitem__(self,idx,val):
        self.children[idx] = val


    def draw(self):
        # Need this to prevent lat/lon being shown in scientific notation
        formatter = matplotlib.ticker.ScalarFormatter(useOffset=False)

        width = max(self.cols * 400 * self.x_scale, MIN_FIG_WIDTH)
        height = max(self.rows * 400 * self.y_scale, MIN_FIG_HEIGHT)

        fig = plt.figure(**fig_params(width,height,96.0))

        for row_i in range(0,self.rows):
            for col_i in range(0,self.cols):
                if self.children[row_i,col_i]:
                    ax = plt.subplot(self.axes[row_i,col_i])
                    ax.yaxis.set_major_formatter(formatter)
                    ax.xaxis.set_major_formatter(formatter)
                    self.children[row_i,col_i].draw(ax)

        fig.tight_layout()

# +++
# Hardcoding max number of columns

MAX_COLUMNS = 3

class GridLayout(object):

    #Generates layout based on field-lookup

    def __init__(self,rows,cols,subview,x_scale=1.0,y_scale=1.0):
        'Specify fields of the source object which will be used to assign layout'
        self.row_field = rows
        self.col_field = cols
        self.subview_class = subview
        self.x_scale = x_scale
        self.y_scale = y_scale

    def generate_view(self,source):
        if self.row_field:
            row_values = source.keys[self.row_field]
            n_rvals = len(row_values)
        else:
            row_values = [None]
            n_rvals = 1

        if self.col_field:
            col_values = source.keys[self.col_field]
            n_cvals = len(col_values)
        else:
            n_cvals = 1

        total_rows = n_rvals * int(np.ceil(n_cvals/float(MAX_COLUMNS)))

        if n_cvals > MAX_COLUMNS:
            n_cols = MAX_COLUMNS
        else:
            n_cols = n_cvals

        view = GridView(total_rows,n_cols,self.x_scale,self.y_scale)

        row_i = 0
        col_i = 0

        q = {}
        for row_val in row_values:
            if row_val:
                q.update({self.row_field: row_val})

            for col_val in col_values:
                if col_val:
                    q.update({self.col_field: col_val})

                if col_i == MAX_COLUMNS:
                    col_i = 0
                    row_i += 1

                results = source.query(q)

                if len(results) == 0:
                    raise Exception
                elif len(results) > 1:
                   raise Exception
                else:
                    cur_var = results.items[0]
                    labels = self.gen_labels(cur_var)
                    if col_i > 0:
                        labels['ylabel'] = ''
                    view[row_i,col_i] = self.subview_class(cur_var,**labels)

                col_i += 1
            col_i = 0
            row_i += 1
        return view


class DefaultSpatialGridLayout(GridLayout):
    '''
    Generates layout based on field-lookup
    '''
    def __init__(self,rows,cols,subview=SpatialView,**kwds):
        super(DefaultSpatialGridLayout,self).__init__(rows,cols,subview,1.6,1.2)
        self.kwds = kwds

    def gen_labels(self,datum):
        dd = {"title": datum[self.col_field],
              "ylabel": "%s" % (dt.pretty_print_period(datum['period'])),
              "units": datum['units'],
              "cmap": 'RdYlBu'}
        if datum.source.name is not None:
            dd['title'] += " " + datum.source.name
        dd.update(self.kwds)
        dd.update(datum)
        for k in 'data','extent':
            if k in dd:
                del dd[k]

        return dd


class ShowNaNGridLayout(GridLayout):
    '''
    Generates layout based on field-lookup
    '''
    def __init__(self,rows,cols,subview=NoBarView):
        super(ShowNaNGridLayout,self).__init__(rows,cols,subview,1.2,0.8)

    def gen_labels(self,datum):
        return {"title": datum[self.col_field], "ylabel": datum[self.row_field],
                "cmap": NAN_FILTER_MAP}


class SpatialAggregateLayout(GridLayout):
    '''
    Generates layout based on field-lookup
    '''
    def __init__(self,**kwds):
        ### Specify fields of the source object which will be used to assign layout
        super(SpatialAggregateLayout,self).__init__('variable','extent',TimeSeriesView,3.5,1.0)
        self.kwds = kwds

    def gen_labels(self,datum):
        labels = {}
        labels['title'] = "%s over area (%s)" % (datum['method'],datum['extent'])
        labels['ylabel'] = "%s" % (datum['units'])
        labels['legend'] = "%s" % datum['variable']
        labels.update(self.kwds)
        return labels

